/*
 * Project: pico9918
 *
 * Copyright (c) 2024 Troy Schrapel
 *
 * This code is licensed under the MIT license
 *
 * https://github.com/visrealm/pico9918
 *
 */

; -----------------------------------------------------------------------------
; tmsRead - monitor the CSR pin and send either status or data value
;
;           due to the read-ahead nature of the TMS9918, we have the 
;           possible read values already. Each tx FIFO word contains
;           the current values for status, read data and pin direction
;
; fifo osr   0b|0000|rrrr|ssssssss|dddddddd|11111111|
;              |    |reg | status |  data  | pindir |
;
;
; fifo isr  
; if mode==1 0b|000|rrrr|ssssssss|dddddddd|11111111|m|
;              |   |reg | status |  data  | pindir |o|
;              |   |    |        |        |        |d|
;              |   |    |        |        |        |e|
;
; if mode==0 0b|m|
;              |o|
;              |d|
;              |e|
;

.program tmsRead
.define public CSR_PIN 26

  pull block
  mov x, osr        ; ensure we have a valid fifo value in x

.wrap_target
  mov osr, null       ; change CD0-7 pindirs to inputs
  wait 1 gpio CSR_PIN ; wait for CSR to go high (inactive) 
  out pindirs, 8
  mov isr, null

pullLoop:
  pull noblock      ; continuously empty the tx fifo
  mov x, osr        ; since we want the latest value
  jmp pin pullLoop

  nop           [7] ; ~32 ns debounce delay for CSR settling (covers typical bounce)
  jmp pin pullLoop  ; if CSR bounced back HIGH, go back to waiting (debounce recovery)
  
  in pins, 1        ; read MODE pin (debounce verified, CSR is stable LOW)
  mov y, isr        ; y contains MODE state
  
  out pindirs, 8    ; set up CD0-7 as outputs
  out pins, 8       ; output data byte

  jmp !y, endPart ; still 1? loop, otherwise, let's read

readStatus:  
  out pins, 8       ; output the status byte
  mov isr, x        ; make this status value available
endPart:
  in pins, 1        ; push CSR, CSW and MODE back through fifo
  push              ; push ^^^ back to cpu to process
.wrap

; -----------------------------------------------------------------------------
; tmsWrite - monitor the CSW pin and pass on pin state via FIFO
;           
;            very simple grab the data and send it through...
;            state at CSW going low in the high 16-bits
;            state at CSW going high in the low 16-bits
;
; fifo isr   0b|x|m|w|r|xxxx|dddddddd|x|m|w|r|xxxx|dddddddd|
;              | |o|r|e|    |  CD0-7 | | | | |    |  CD0-7 |
;              | |d|i|a|    | ignore | | | | |    |        |
;              | |e|t|d|    |        | | | | |    |        |
;              | | |e| |    |        | | | | |    |        |

.program tmsWrite
.define public CSW_PIN 27

  wait 0 gpio CSW_PIN [7]   ; wait for CSW to go active (low)
  in pins, 16               ; grab the initial (mode) state
pollWriteLoop:
  mov x, pins               ; continuously grab pin state
  jmp pin captureWrite      ; and wait for csw high
  jmp pollWriteLoop
captureWrite:
  nop                 [7]   ; ~32 ns debounce delay for CSW settling
  jmp pin confirmed         ; if CSW still HIGH, it's stable
  jmp pollWriteLoop         ; if CSW bounced back LOW, retry
confirmed:
  in x, 16                  ; grab the final state (CSW confirmed stable HIGH)
.wrap
